<aside>
💡

**함수 선언과 실행 순서**

웹 브라우저에서는 자바스크립트 코드 가운데 함수 선언 부분을 가장 먼저 해석한다.

</aside>

# 1. 매개변수

---

## 1.1 기본 매개변수

기본 매개변수란 매개변수를 입력하지 않았을 때, 매개변수를 강제로 초기화하는 것을 뜻한다.

### 1.1.1 기존 방법

**<일반 조건문>**

```jsx
<script>
	function test(a, b, c) {
		if(!b) {b=52;}
		if(!c) {c=273;}
	}
	test(1, 2);
</script>
```

**<짧은 조건문 - 가독성의 이유로 더 많이 사용한다>**

```jsx
<script>
	function test(a, b, c) {
		b = b || 52;
		c = c || 273;
	}
	test(1, 2);
</script>
```

### 1.1.2 ES6 방법

```jsx
<script>
	function test(a, b=52, c=273){ }
	test(1, 2);
</script>
```

# 2. 함수 표현식

---

## 2.1 익명 함수

익명 함수는 선언 시 이름을 붙이지 않은 함수이다.

변수에 할당해 사용하거나, 다른 함수의 매개변수로 쓸 수 있다.

```jsx
var 함수 = function() { };
```

## 2.2 선언적 함수

선언적 함수는 이름을 붙인 함수이다.

```jsx
function 함수(){ };
```

## 2.3 즉시 실행 함수

일반적으로 함수는 선언 후 필요에 의해 호출해 실행하지만 즉시 실행 함수는 정의하면서 동시에 실행할 수 있다. 즉, 호출 없이 사용할 수 있다.

변수의 스코프를 제한해서 코드 사이에 충돌이 생기는 것을 방지하기 위해 사용한다.

```jsx
// 기본형1
	(function(){명령}()};
//기본형2
	(function(매개변수){명령}(인수))
```

## 2.4 화살표 함수

함수 선언을 좀 더 간단하게 작성한 버전으로 함수 이름이 없을 경우에만 사용할 수 있다.

```jsx
(매개변수) => {함수 내용}

//한줄인 경우
(매개변수) => 함수내용
```

## 2.5 익명 함수와 선언적 함수의 차이와 호출 순서 *

```jsx
// 선언적 함수
function 함수() { alert('함수 A') }
function 함수() { alert('함수 B') }

// 익명함수
var 함수 = function () { alert('함수 A')}
var 함수 = function () { alert('함수 B')}
```

위와 같이 선언적 함수와 익명 함수 각각 재 선언을 하는 경우 둘 다 나중에 할당된 alert (’함수 B’)로 덮어 씌어져 ‘함수 B’ 가 출력 된다.

```jsx
var 함수 = function () { alert('함수 A'); }
function 함수() { alert('함수 B'); }

함수();
```

그렇다면 **익명 함수 → 선언적 함수 순서**로 선언하면 어떻게 될까?

웹 브라우저는 script 태그 내부의 내용을 한 줄씩 읽기 전에 **선언적 함수부터 읽는다.**

즉, 선언적 함수가 실행되고 이후 익명 함수가 덮어 씌어지기 때문에 위 코드 결과는 ‘함수 A’ 가 된다.

***결론) 실행순서 : 선언적 함수 → 익명 함수***

## 2.6 콜백 함수와 클로저 *

### 2.6.1 콜백 함수

자바스크립트에서는 함수도 하나의 자료형이므로 매개변수로 전달할 수 있다. 이를 콜백 함수라 한다.

이에 당연히 함수를 return할 수도 있다.

### 2.6.2 클로저

클로저란 **함수 안에서 만든 변수를 함수 밖에서도 계속 사용할 수 있게 해주는 기능**이다.

함수 안에서 만든 변수는 함수가 끝나면 사라져야 하지만, 클로저를 사용하면 사라지지 않고 계속 기억할 수 있다.

```jsx
function counterMaker() {
  let count = 0; // 함수 내부 변수

  return function () {
    count++;
    console.log(count);
  };
}

const counter = counterMaker(); // counter에 내부 함수 저장

counter(); // 1
counter(); // 2
counter(); // 3

```

# 3. 이벤트와 이벤트 처리기

---

이벤트란 키모드, 마우스 등 을 이용해 다른 것에 영향을 미치는 것을 의미한다.

## 3.1 이벤트 관련 용어 정리

```jsx
window.onload = function () { };
```

- **이벤트에 연결한다** : 속성에 함수 자료형을 할당하는 것을 의미함
- **load** : 이벤트 타입
- **onload** : 이벤트 속성
- **이벤트 리스너(이벤트 핸들러**) : 이벤트 속성에 할당한 함수
- **이벤트 모델** : 문서 객체에 이벤트를 연결하는 방법
    - DOM level 0
        - 인라인 이벤트 모델
        - 기본 이벤트 모델
    - DOM level 2
        - 마이크로소프트 인터넷 익스플로러 이벤트 모델
        - 표준 이벤트 모델

---

## 3.2 이벤트 종류

### 3.2.1 마우스 이벤트

| 이벤트 | 설명 |
| --- | --- |
| `click` | 요소 클릭 |
| `dbclick` | 더블 클릭 |
| `mousedown` | 마우스 버튼 눌렀을 때 |
| `mousemove` | 포인터가 요소 위에서 움직일 때 |
| `mouseover` | 포인터가 요소 위로 옮겨질 때 |
| `mouseout` | 포인터가 요소를 벗어날 때 |
| `mouseup` | 마우스 버튼에서 손을 뗄 때 |

### 3.2.2 키보드 이벤트

| 이벤트 | 설명 |
| --- | --- |
| `keydown` | 키를 누르는 동안 |
| `keypress` | 키를 눌렀을 때 |
| `keyup` | 키에서 손을 뗄 때 |

### 3.2.3 문서 로딩 이벤트

| 이벤트 | 설명 |
| --- | --- |
| `abort` | 완전히 로딩되기 전 불러오기를 멈췄을 때 |
| `error` | 정확이 로딩되지 않았을 때 |
| `load` | 로딩이 끝나면 |
| `resize` | 문서 화면 크기가 바뀌었을 때 |
| `scroll` | 문서 화면이 스크롤되었을 때 |
| `unload` | 문서에서 벗어날 때 |

### 3.2.4 폼 이벤트

| 이벤트 | 설명 |
| --- | --- |
| `blur` | 폼 요소에서 포커스가 벗어났을 때 |
| `change` | 목록이나 체크 상태 등이 변경 될 때 |
| `focus` | 폼 요소에 포커스가 놓였을 때 |
| `reset` | 폼이 리셋 되었을 때 |
| `submit` | submit 버튼을 클릭했을 때 |

---

## 3.3 이벤트 모델 - DOM Level 0 *

아래에서 설명할 인라인 이벤트 모델과 고전 이벤트 모델은 DOM Level 0 모델들로 한 번에 하나의 이벤트 리스너만 가질 수 있다.

### 3.3.1 인라인 이벤트 모델

가장 기본적인 이벤트 연결 방법, 그러나 지저분해지기 때문에 script 태그 안에 만들고 이를 호출하는 방식을 많이 사용한다.

**태그의 이벤트 속성 안에 코드를 모두 쓴 경우**

```jsx
<h1 onclick="var alpha=10; alpha=10;alert(alpha);">Click</h1>
```

**<script> 태그에 코드를 쓴 경우**

```jsx
<head>
	<script>
		function whenClick(e) {
			alert('클릭');
		}
	</script>
</head>
```

### 3.3.2 고전 이벤트 모델

자바스크립트에서 문서 객체의 이벤트 속성으로 이벤트를 연결하는 방법이다. 이름은 고전이지만 현대에도 많이 사용한다.

**<고전 이벤트 모델의 이벤트 연결>**

```jsx
<body>
	<h1 id="header">Click</h1>
</body>
```

```jsx
<script>
	window.onload = function () {
		var header = document.getElementById('header');
		
		header.onclick = function(){
			alert('클릭')
		}
	}
</script>
```

**<고전 이벤트 모델의 이벤트 제거>**

이벤트 속성에 null을 넣어 이벤트를 제거할 수 있다.

```jsx
<script>
	window.onload = function () {
		var header = document.getElementById('header');
		
		header.onclick = function(){
			alert('클릭')
				
				// 이벤트 제거
				header.onClick=null;
		}
	}
</script>
```

**이벤트 발생 객체와 이벤트 객체**

이벤트는 ‘누가, 언제, 어디서, 무엇을, 어떻게, 왜’로 정의된다.

- 누가 = 이벤트 객체
- 무엇을 = 이벤트 발생 객체

이벤트 리스너 안에서 `this` 키워드를 사용하면 ‘**이벤트 발생 객체**’ 를 의미하고 ‘**이벤트 객체’**는 `window.event` 를 통해 가르킬 수있다. 

**이벤트 강제 실행**

이벤트를 강제로 실행하는 기술은 자주 사용되지 않지만 적절하게 사용하면 코드 길이를 감소 시킬 수 있다.

**<강제 실행 예제>**

- 버튼A click시 A의 숫자 1 증가
- 버튼B click시 B의 숫자 1증가 & A의 숫자 1증가

```jsx
// 강제 실행 X
buttonA.onClick = function(){
    A.innerHTML = Number(A.innerHTML) + 1;
}

buttonB.onClick = function(){
    B.innerHTML = Number(B.innerHTML) + 1;
    A.innerHTML = Number(A.innerHTML) + 1;
}

// 강제 실행 O
buttonA.onClick = function(){
    A.innerHTML = Number(A.innerHTML) + 1;
}

buttonB.onClick = function(){
    B.innerHTML = Number(B.innerHTML) + 1;
    buttonA.onClick();
}
```

---

## 3.4 이벤트 모델 - DOM Level 2 *

DOM Level 0 이벤트 모델의 한 번에 하나의 이벤트 리스너만 가질 수 있다는 단점을 보완하고자 만들어진 이벤트 모델이 DOM Level 2 이벤트 모델이다.

### 3.4.1 인터넷 익스플로러 모델

인터넷 익스플로러 모델은 국내에서 많이 사용되며 두 가지 메서드로 이벤트를 연결하거나 제거할 수 있다.

이는 인터넷 익스플로러에만 있기 때문에 사용시 별도의 조건문이 필요하다.

```jsx
attachEvent(eventPropertym eventListener);
detachEvent(eventProperty, eventListener);
```

**<이벤트 연결>**

```jsx
<script>
    window.attachEvent('onload', function(){
        var header = document.getElementById('my-header');

        header.attachEvent('onclick', function () {alert('클릭');});
        header.attachEvent('onclick', function () {alert('클릭');});
        header.attachEvent('onclick', function () {alert('클릭');});
    })
</script>
```

**<이벤트 제거>**

```jsx
<script>
    window.attachEvent('onload', function(){
        var header = document.getElementById('my-header');

        header.attachEvent('onclick', function () {alert('클릭');});
        header.detachEvent('onclick', function () {alert('클릭');});
    })
</script>
```

- 익명 함수를 사용한 이벤트는 제거할 수 없다.
- 위 코드의 경우 연결과 동시에 제거했기 때문에 경고창이 출력 되지 않는다.

**this**

인터넷 익스플로러 이벤트 모델에서 이벤트 리스너의 `this` 키워드는 이벤트 발생 객체가 아니다.

`this` 키워드는 window 객체를 나타내며 이벤트 발생 객체를 사용하려면 `srcElement` 속성을 사용해야 한다.

### 3.4.2 표준 이벤트 모델

W3C에서 공식 지정한 DOM Level 2 이벤트 모델이다. 한 번에 여러 가지의 이벤트 리스너를 추가할 수 있으며 캡처링을 지원하지만 사실상 거의 쓰이지 않는다.

```jsx
addEventListener(eventName, handler, useCapture)
removeEventListener(evenName, handler)
```

**<이벤트 연결>**

```jsx
<script>
    window.onload = function(){
        var header = document.getElementById('my-header');

        header.addEventListener('click', function(){
            this.innerHTML += '+';
        });
    };
</script>
```

**this**

표준 이벤트 모델은 이벤트 리스너 안에서 `this` 키워드가 이벤트 발생 객체를 의미한다. 

---

## 3.5 디폴트 이벤트 제거 *

디폴트 이벤트란 HTML 태그가 이미 가지고 있는 이벤트 리스너이다.  그 예로 `<a>`, `<from>` 은 각각 url 이동, submit 이벤트를 가지고 있다.

이에 이벤트 리스너에서 디폴트 이벤트의 `return` 값을 `false`로 바꾸면 디폴트 이벤트가 제거된다.

```jsx
<script>
    window.onload = function(){
        document.getElementById('my-form').onsubmit = function(){
            return false;
        }
    }
</script>
```

---

## 3.6 이벤트 전달 *

태그가 계층적으로 이루어짐에 따라 이벤트가 발생하는 경우 연쇄적 이벤트 흐름이 일어나게 된다.

아래 코드는 p 박스를 클릭하는 경우 부모인 div와 form도 발생하게 된다. 이러한 현상을 이벤트 전달이라 부르며, 전파 방향에 따라 버블링과 캡처링으로 구분한다.

```jsx
<form onclick="alert('form')">FORM
    <div onclick="alert('div')">DIV
    	<p onclick="alert('p')">P</p>
    </div>
</form>
```

![image.png](attachment:232a5667-02c1-46f7-ac29-c0c30d9c32c8:image.png)

- **이벤트 버블링** : 자식 노드 → 부모 순으로 이벤트 실행
- **이벤트 캡쳐링** : 부모 노드 → 자식 노드 순으로 이벤트 실행

일반적으로 버블링이 기본값이기 때문에 캡처링으로 설정하기 위해선 별도의 옵션을 줘야한다.

`이벤트 대상.addEventListener(’eventType’, functionName, [useCapture])`

`useCapture`의 값을 `true`로 주면 캡처링, `false`로 주면 버블링을 사용한다.

### **3.6.1 이벤트 전달 막기**

불필요한 전달을 방지하기 위해 이벤트 전달을 막는 것도 필요하다.

- 인터넷 익스플로러 : 이벤트 객체의 cancelBubble 속성을 true로 변경
- 그 의외 브라우저 : 이벤트 객체의 stopPropagaion() 메서드 사용

**<예제>**

```jsx
document.getElementById('garagraph').onClick = function (e) {
	// 이벤트 객체 처리
	var event = e || window.event;
	
	// 이벤트 전달 제거
	event.cancelBubble = true;
	if(event,stop{ropagation){
		event.stopPropagation();
	}	
}
```