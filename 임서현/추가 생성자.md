# 1. 생성자

---

```jsx
function Student(name, korean, math){
	this.이름 = name;
	this.국어 = korean;
	this.수학 = math;
	
	// 생성자 안에 메서드를 둘 수 있다.
	this.getSum = function (){
		return this.국어 + this.수학;
	};
}
var student = new Student();
```

- `Student()`는 생성자 함수로 `new` 키워드를 통해 객체를 생성한다.
- 생성자 함수 안에서 this를 이용해 내부 속성을 지정한다.
- 생성자 함수는 대문자로 시작한다

## 1.1 생성자 함수와 일반 함수와의 차이

겉보기에는 생성자 함수와 일반 함수의 차이가 없다. 그렇다면 왜 굳이 생성자 함수를 사용할까?

### 프로토타입

<aside>

**일반 함수 객체 생성**

- [객체A - 속성, 메서드]
- [객체B - 속성, 메서드]
- [객체C - 속성, 메서드] …
</aside>

<aside>

**생성자 함수 객체 생성**

- [객체A - 속성]
- [객체B - 속성]             ⇒       [메서드]
- [객체C - 속성]
</aside>

![image.png](attachment:ea38bfb8-1e82-4440-a3c9-2d95e4457740:image.png)

일반 함수로 생성하는 객체는 속성이 다를지언정 메서드가 모두 같아 객체를 1000건 생성하면 중복되는 메서드도 1000건을 생성하는 구조였다. 이런 쓸데없는 메모리차지를 해결하고자 프로토타입이라는 공간이 생겼다. 프로토타입을 통해 메서드를 하나만 생성해도 모든 객체가 해당 메서드를 사용할 수 있다. 

생성자 함수를 통해 객체를 생성하면 자동으로 객체 내부에 prototype 객체를 갖는다.

---

# 2. 상속

---

한 객체가 다른 객체의 속성과 메서드를 물려받아 재사용하는 기술을 의미한다. 자바스크립트는 프로토타입 기반 상속을 사용한다.

(프로토타입이 class와 유사한 역할을 한다고 생각하면 된다.)

## 2.1 프로토타입 기반 상속

<기본 구조>

```jsx
// 부모 메서드(생성자 함수)
 function Rectangle(w,h) {
    
    var width = w;
    var height = h;

    this.getWidth = function(){return width;};
    this.getHeight = function(){return height;};

 }

// 자식 메서드
function Square(length) {
    // 방법1. Square 내부 속성을 이용해 Rectangle의 속성 상속 받기
    this.childRectangle = Rectangle; 
    this.childRectangle(length, length);
}    

		//방법2. Square 프로토타입을 이용해 REctangle의 속성 및 메서드 상속 받기
Square.prototype = Rectangle.prototype;
Square.prototype.constructor = Square;

```

- 사용시에는 프로토타입 체인을 이용한다.
- `constructor()` : 상속으로 인해 Square의 생성자가 Rectangle로 변경됐을 가능성O→ Square 값을 할당해 생성자 정보를 수동으로 복구

***→ 이러한 수동 복구는 혼란을 일으키기 쉽기 때문에 최근에는 거의 사용하지 않는다.***

***그렇다면 어떤 방법으로 상속을 구현할까?***

# 3. 클래스 (ECMAScript6)

---

ECMAScript6 부터 클래스 기반의 객체지향 언어를 도입하게 되었다.

## **3.1 class 기반 상속**

class 개념이 도입되며 위 프로토타입 기반 상속 대신 클래스 기반 상속을 사용하게 되었다.

```jsx
class Rectangle {
  constructor(w, h) {
    this.w = w;
    this.h = h;
  }
}

class Square extends Rectangle {
  constructor(length) {
    super(length, length); // 부모 생성자 호출
  }
}

const s = new Square(5);
```

**아래는 Class 가 도입되며 변경된 항목들이다.**

## **3.2 클래스 선언과 속성**

**classX 생성자**

```jsx
function Rectangle(width, height){
	...
}
var rectangle = new REctangle(100, 200);
```

**classO 생성자**

```jsx
class Rectangle {
	constructor(width, height){
		...
	}
}
const rectangle = new Rectangle(100, 200);
```

## **3.3 메서드 선언**

**ClassX**

```jsx
function Rectangle(width, height){...}

Rectangle.prototype.getArea = function () {return this.width * this/height;}

var rectangle = new Rectangle(100, 200);
```

**ClassO**

```jsx
Class Rectangle{
	constructor(width, height){...}
	
	getArea(){...}
}

const rectangle = new Rectangle(100, 200);
```

## **3.4 getter와 setter**

**ClassX**

```jsx
function Person(name) {
  this._name = name;
}

// getter
Person.prototype.getName = function() {
  return this._name;
};

// setter
Person.prototype.setName = function(value) {
  this._name = value;
};

const p = new Person("길동");
console.log(p.getName()); // 길동
p.setName("홍길동");
console.log(p.getName()); // 홍길동

```

**ClassO**

```jsx
class Person {
  constructor(name) {
    this._name = name;
  }

  // getter
  get name() {
    return this._name;
  }

  // setter
  set name(value) {
    this._name = value;
  }
}

const p = new Person("길동");
console.log(p.name);   // getter 호출 → 길동
p.name = "홍길동";      // setter 호출
console.log(p.name);   // 홍길동

```

- `set()`, `get()`이라는 자동화된 메서드를 사용
- 변수 앞에 `_`를 붙여 값을 변경하지 말 것을 표시

그러나 게터와 세터를 사용하면 스택 추적 확인, 유지보수가 어렵고 메서드 체이닝에 활용하기 힘들기 때문에 사용하지 말 것을 권한다.